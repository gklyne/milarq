

# Introduction #

This page contains notes about using SPARQL within the MILARQ and CLAROS projects.

SPARQL is used for run-time queries and for generating "inferred" intermediate data used (among other things) to speed up some of the run-time queries.

# Details #

## Double-counting ##

The logic to avoid double-counting when an object resides in more than one place is flawed.  Arachne describes Athens as lying within both Frankreich and Griechenland, which causes two entries for an object found in Athens to be made in the count summaries, rather than multiple regions added to the same entry.

Consider a simplified example based on the following raw data:
```
ex:v1 ex:place "Athens".
ex:v2 ex:place "Athens", "Frankreich" .
ex:v3 ex:place "Athens", "Frankreich" .
ex:v4 ex:place "Athens", "Griechenland" .
ex:v1 ex:place "Athens", "Frankreich", "Griechenland" .
```

The correspondingly simplified version of the incorrect query would be:
```
CONSTRUCT
    {
      [ ex:place     ?place
      ; claros:count ?c
      ]
    }
WHERE
    { SELECT ?place (COUNT (*) AS ?c) WHERE
        { ?s ex:place ?place } GROUP BY ?place
    }
```
generating a result like this:
```
_:c1 ex:place "Athens" ; ex:count 5 .
_:c2 ex:place "Frankreich" ; ex:count 3 .
_:c3 ex:place "Griechenland" ; ex:count 2 .
```

I'm looking for a CONSTRUCT query to reduce the original data to:
```
_:c1 ex:place "Athens" ; ex:count 1 .
_:c2 ex:place "Athens", "Frankreich" ; ex:count 2 .
_:c3 ex:place "Athens", "Griechenland" ; ex:count 1 .
_:c4 ex:place "Athens", "Frankreich", "Griechenland" ; ex:count 1 .
```

So that a query like this returns ?count == 5:
```
SELECT (SUM (?c) as ?count) WHERE
  [ ex:place "Athens" ; ex:count ?c ]
```
and this returns ?count == 3:
```
SELECT (SUM (?c) as ?count) WHERE
  [ ex:place "Frankreich" ; ex:count ?c ]
```
and (crucially) this returns ?count == 5:
```
SELECT (SUM (?c) as ?count) WHERE
  [ ex:count ?c ]
```

This requirement can be achieved by a combination of [GROUP\_CONCAT](http://www.w3.org/2009/sparql/docs/query-1.1/rq25.xml#setFunctions) and [BNODE](http://www.w3.org/2009/sparql/docs/query-1.1/rq25.xml#func-bnode) functions.  @@TODO: update links when these functions make it into a stable working draft. Also, for general string concatenation, there is [fn:concat](http://www.w3.org/TR/xpath-functions/#func-concat).

So the original stated goal may be satisfied by this query:
```
# SPARQL query to construct object counts statements for each combination of associated places

PREFIX rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs:    <http://www.w3.org/2000/01/rdf-schema#>
PREFIX pf:      <http://jena.hpl.hp.com/ARQ/property#>
PREFIX fn:      <http://www.w3.org/2005/xpath-functions#>
PREFIX xsd:     <http://www.w3.org/2001/XMLSchema#>
PREFIX ex:      <http://example.org/>

CONSTRUCT
 { ?bn ex:place ?p
   ;   ex:count ?c
 }
WHERE
  {
    # Associate bnode key value with each subject
    { SELECT ?s (GROUP_CONCAT(?p;SEPARATOR="::") as ?pp) WHERE
      { ?s ex:place ?p
      } GROUP BY ?s
    }
    # Associate new bnode with each key value
    { SELECT ?pp (BNODE(?pp) AS ?bn) WHERE
      { SELECT DISTINCT (GROUP_CONCAT(?p;SEPARATOR="::") as ?pp) WHERE
        { ?s ex:place ?p
        } GROUP BY ?s
      }
    }
    # Associate count with each bnode
    { SELECT ?pp (COUNT(DISTINCT ?s) AS ?c) WHERE
      { SELECT ?s (GROUP_CONCAT(?p;SEPARATOR="::") as ?pp) WHERE
        { ?s ex:place ?p
        } GROUP BY ?s
      } GROUP BY ?pp
    }
    # Associate places with each bnode
    ?s ex:place ?p
  }
```

In practice, the key values used for bnode generation are precalculated and added to the triple store.  This is both faster and easier to maintain, as the key-generating query does not have to be repeated.

## OPTIONAL in braces doesn't work as might be expected ##

Note that graph patterns:
```
PQ1: P OPTIONAL Q
```
and
```
PQ2: P {OPTIONAL Q}
```
do not, in general, return the same solution sets.

To see why this is so, consider the query algebra.

Let `Sp` be a solution set generated by matching `P` and `Sq` a solution set generated by matching `Q`, `T` an expression such that `T(s) = True` for any solution `s`, and `Se` an empty solution set (e.g. as generated by matching the empty pattern).

Then the solution set generated matching `PQ1` is:
```
   Spq1 = LeftJoin(Sp,Sq,T)
        = Filter(T,Join(Sp,Sq)) set-union Diff(Sp,Sq,T)
        = Join(Sp, Sq) set-union Diff(Sp,Sq,T)
```

The solution set generated by matching `PQ2` is:
```
   Spq2 = Join(Sp,LeftJoin(Se,Sq,T))
        = Join(Sp,Filter(T,Join(Se,Sq)) set-union Diff(Se,Sq,T)
        = Join(Sp,Join(Se,Sq) set-union Diff(Se,Sq,T)
        = Join(Sp,Sq) set-union Diff(Se,Sq,T)
        = Join(Sp,Sq)
```

Note that by examining the definition of `Diff`, we see `Diff(Se,x,e)` is equal to the empty solution set `Se` for all `x` and `e`.  So we see the difference between the solutions having `Q` enclosed or not enclosed in braces is determined substantially by the value of `Diff(Sp,Sq,T)`; when this is empty, the two patterns generate the same solutions, but if it is non-empty they may be different.